name: Build CVM Image

on:
  push:
    tags:
      - 'cvmimage-v*'
  pull_request:
    paths:
      - 'system/cvmimage'
      - '.github/workflows/system-cvmimage.yml'
  workflow_dispatch:
    inputs:
      kernel_release:
        description: 'Kernel release tag (e.g., kernel-v6.14.0-28). Leave empty for latest.'
        required: false
        default: ''

permissions:
  contents: write
  id-token: write
  attestations: write

jobs:
  build:
    name: Build CVM Image
    runs-on: xlarge

    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6.0.1
        with:
          submodules: recursive

      - name: Ensure gh CLI supports attestation (>= 2.67.0)
        run: |
          GH_VERSION=$(gh --version | head -1 | awk '{print $3}')
          MIN_VERSION="2.67.0"
          echo "gh version: $GH_VERSION (minimum: $MIN_VERSION)"
          
          if [ "$(printf '%s\n' "$MIN_VERSION" "$GH_VERSION" | sort -V | head -1)" != "$MIN_VERSION" ]; then
            echo "ERROR: gh CLI version $GH_VERSION is too old. Need >= $MIN_VERSION for attestation support."
            exit 1
          fi

      - name: Determine kernel release
        id: kernel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -n "${{ inputs.kernel_release }}" ]; then
            KERNEL_RELEASE="${{ inputs.kernel_release }}"
          else
            # Get latest kernel release using JSON for reliability
            KERNEL_RELEASE=$(gh release list --json tagName \
              --jq '[.[] | select(.tagName | startswith("kernel-v"))][0].tagName')
          fi
          
          if [ -z "$KERNEL_RELEASE" ] || [ "$KERNEL_RELEASE" = "null" ]; then
            echo "ERROR: No kernel release found!"
            exit 1
          fi
          
          echo "release=$KERNEL_RELEASE" >> "$GITHUB_OUTPUT"
          echo "Using kernel release: $KERNEL_RELEASE"

      - name: Download kernel artifacts
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p /tmp/kernel-artifacts
          
          echo "Downloading from release: ${{ steps.kernel.outputs.release }}"
          gh release download "${{ steps.kernel.outputs.release }}" \
            -p '*.deb' \
            -p 'nvidia-modules.tar.gz' \
            -p 'checksums.sha256' \
            -D /tmp/kernel-artifacts/

      - name: Verify artifacts with Sigstore (GitHub-hosted only)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Verifying artifact attestations..."
          cd /tmp/kernel-artifacts
          
          verify_artifact() {
            local artifact="$1"
            echo "Verifying $artifact..."
            gh attestation verify "$artifact" \
              -R ${{ github.repository }} \
              --deny-self-hosted-runners || {
              echo "ERROR: Attestation verification failed for $artifact"
              exit 1
            }
            echo "✓ $artifact verified"
          }
          
          # Verify checksums first
          sha256sum -c checksums.sha256
          
          # Verify each artifact
          for deb in *.deb; do
            verify_artifact "$deb"
          done
          
          verify_artifact "nvidia-modules.tar.gz"
          
          echo "✓ All artifacts verified: signed and built on GitHub-hosted runners!"

      - name: Install verified artifacts
        run: |
          # Create target directories
          mkdir -p system/build/packages
          mkdir -p system/build/nvidia-modules
          
          # Copy verified .deb packages
          cp /tmp/kernel-artifacts/*.deb system/build/packages/
          
          # Extract verified NVIDIA modules
          tar -xzf /tmp/kernel-artifacts/nvidia-modules.tar.gz -C system/build/
          
          # Cleanup temp
          rm -rf /tmp/kernel-artifacts
          
          echo "Installed artifacts:"
          ls -la system/build/packages/
          ls -la system/build/nvidia-modules/

      - name: Install mkosi
        run: |
          # Use Ubuntu snapshot to pin packages
          SNAPSHOT_DATE="20250107T000000Z"
          echo "deb [check-valid-until=no] https://snapshot.ubuntu.com/ubuntu/${SNAPSHOT_DATE} noble main restricted universe multiverse" | sudo tee /etc/apt/sources.list
          echo "deb [check-valid-until=no] https://snapshot.ubuntu.com/ubuntu/${SNAPSHOT_DATE} noble-updates main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
          echo "deb [check-valid-until=no] https://snapshot.ubuntu.com/ubuntu/${SNAPSHOT_DATE} noble-security main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
    
          sudo apt-get update
          sudo apt-get install -y pipx ubuntu-keyring debian-archive-keyring make jq binutils
          sudo pipx install git+https://github.com/systemd/mkosi.git@54c625c380ef5500f17460981a3c67b109b6a847 #v25.3
          sudo pipx ensurepath

      - name: Build CVM image
        run: |
          cd system/cvmimage
          sudo /opt/pipx_bin/mkosi --image-version ${{ github.ref_name || 'dev' }}

      - name: Fix permissions
        run: |
          cd system/cvmimage
          sudo chmod 644 tinfoilcvm.*
          sudo chown $USER:$USER tinfoilcvm.*

      - name: Generate manifest
        id: manifest
        run: |
          cd system/cvmimage
          mkdir -p out
          
          # Generate manifest JSON
          cat > out/manifest.json << EOF
          {
            "version": "${{ github.ref_name || 'dev' }}",
            "kernel_release": "${{ steps.kernel.outputs.release }}",
            "root": "$(objcopy -O binary --only-section .cmdline tinfoilcvm.efi /dev/stdout | cut -d "=" -f 2)",
            "initrd": "$(sha256sum tinfoilcvm.initrd | awk '{print $1}')",
            "kernel": "$(sha256sum tinfoilcvm.vmlinuz | awk '{print $1}')",
            "raw": "$(sha256sum tinfoilcvm.raw | awk '{print $1}')",
            "built_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          # Copy artifacts
          cp tinfoilcvm.initrd tinfoilcvm.vmlinuz tinfoilcvm.raw out/
          
          # Generate checksums
          cd out
          sha256sum * | tee checksums.sha256
          
          # Output for release body
          echo "manifest<<EOF" >> "$GITHUB_OUTPUT"
          cat manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Upload artifacts
        if: "!startsWith(github.ref, 'refs/tags/cvmimage-v')"
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: cvmimage
          path: |
            system/cvmimage/out/

      - name: Attest artifacts
        if: startsWith(github.ref, 'refs/tags/cvmimage-v')
        uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a  # v3.0.0
        with:
          subject-path: |
            system/cvmimage/out/manifest.json
            system/cvmimage/out/tinfoilcvm.initrd
            system/cvmimage/out/tinfoilcvm.vmlinuz
            system/cvmimage/out/tinfoilcvm.raw

      - name: Prepare versioned artifacts for R2
        if: startsWith(github.ref, 'refs/tags/cvmimage-v')
        run: |
          cd system/cvmimage/out
          # Extract version from tag (cvmimage-v0.0.2 -> v0.0.2)
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#cvmimage-}"
          
          mv tinfoilcvm.initrd "tinfoilcvm-${VERSION}.initrd"
          mv tinfoilcvm.vmlinuz "tinfoilcvm-${VERSION}.vmlinuz"
          mv tinfoilcvm.raw "tinfoilcvm-${VERSION}.raw"
          mv manifest.json "manifest-${VERSION}.json"
          mv checksums.sha256 "checksums-${VERSION}.sha256"
          
          echo "Versioned artifacts:"
          ls -la

      - name: Upload to R2
        if: startsWith(github.ref, 'refs/tags/cvmimage-v')
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_IMAGES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_IMAGES_SECRET_ACCESS_KEY }}
          AWS_ENDPOINT_URL: https://${{ secrets.R2_IMAGES_ACCOUNT_ID }}.r2.cloudflarestorage.com
        run: |
          for file in system/cvmimage/out/*; do
            aws s3 cp "$file" "s3://${{ secrets.R2_IMAGES_BUCKET }}/cvm/$(basename "$file")"
          done

      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/cvmimage-v')
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cd system/cvmimage/out
          
          # Extract version for URLs
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#cvmimage-}"
          
          gh release create "${{ github.ref_name }}" \
            -R ${{ github.repository }} \
            --latest=false \
            --title "${{ github.ref_name }}" \
            --notes "Built using kernel release: \`${{ steps.kernel.outputs.release }}\`

          ### Downloads
          - Kernel: https://images.tinfoil.sh/cvm/tinfoilcvm-${VERSION}.vmlinuz
          - Initrd: https://images.tinfoil.sh/cvm/tinfoilcvm-${VERSION}.initrd
          - Disk: https://images.tinfoil.sh/cvm/tinfoilcvm-${VERSION}.raw

          ### Manifest
          \`\`\`json
          $(cat manifest-${VERSION}.json)
          \`\`\`" \
            manifest-${VERSION}.json \
            checksums-${VERSION}.sha256